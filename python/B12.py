#!/usr/bin/env python

# Copyright Greg Hogan, 2012. Last modified 2015.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but without any warranty; without even the implied warranty of
# merchantability or fitness for a particular purpose.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
The following problem is taken from Project Euler,
    https://projecteuler.net/problem=12
licenced under a Creative Commons Licence:
    Attribution-NonCommercial-ShareAlike 2.0 UK: England & Wales

Problem 12
08 March 2002

The sequence of triangle numbers is generated by adding the natural numbers. So
the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten
terms would be:

    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
"""

import functools
import math
import operator

from A5 import factor_map


def triangle_number_generator(limit=None):
    """The sequence generated by adding the natural numbers.

    >>> list(triangle_number_generator(100))
    [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91]
    """

    number = 0
    triangle_number = 0

    while True:
        number += 1
        triangle_number += number

        if limit and triangle_number > limit:
            break

        yield(triangle_number)


def divisor_count(n):
    """Compute the number of divisors for the given integer.

    >>> divisor_count(7)
    2
    >>> divisor_count(12)
    6
    >>> divisor_count(36)
    9
    >>> divisor_count(math.factorial(5))
    16
    >>> divisor_count(math.factorial(15))
    4032
    """

    # Each divisor is a product of multiples of each prime factor.
    factor_counts = factor_map(n).values()

    # Compute the product of factor counts, incrementing since a factor may
    # be taken to the 0th power.
    return functools.reduce(operator.mul, (1 + count for count in factor_counts), 1)


def using_factorization(factors):
    """Compute the first triangle number with more than the given number of
    factors. The prime factorization is computed first.

    >>> using_factorization(5)
    28
    >>> using_factorization(8)
    36
    >>> using_factorization(9)
    120
    >>> using_factorization(500)
    76576500
    """

    for triangle_number in triangle_number_generator():
        if divisor_count(triangle_number) > factors:
            return triangle_number


def naive(factors):
    """Compute the first triangle number with more than the given number of
    factors. This method simply tests each potential divisor less than or
    equal to the square root of the triangular number.

    >>> naive(5)
    28
    >>> naive(8)
    36
    >>> naive(9)
    120
    >>> naive(500)
    76576500
    """

    for triangle_number in triangle_number_generator():
        count = 0

        # test only the lower half of the divisor range
        for x in range(1, int(math.sqrt(triangle_number)) + 1):
            div, mod = divmod(triangle_number, x)
            if mod == 0:
                if div == x:
                    # if div * div == triangle_number only count one factor
                    count += 1
                else:
                    # also count the factor > sqrt(triangle_number)
                    count += 2

        if count > factors:
            return triangle_number


if __name__ == "__main__":
    import doctest
    doctest.testmod()
